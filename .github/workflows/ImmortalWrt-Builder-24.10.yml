name: ImmortalWrt-Builder-24.10

on:
  repository_dispatch:
  workflow_dispatch:
    inputs:
      device_model:
        description: 'Select target device model'
        type: choice
        required: true
        options:
          - cmcc_rax3000m
          - cmcc_rax3000m-emmc
          - cmcc_rax3000m-usboffload
          - cmcc_rax3000m-emmc-usboffload
          - abt_asr3000
          - cetron_ct3003
          - cmcc_a10
          - h3c_nx30pro
          - imou_lc-hx3001
          - jcg_q30
          - konka_komi-a31
          - livinet_zr-3020
          - mt7981-360-t7-108M
          - mt7981-clt-r30b1
          - mt7981-clt-r30b1-112M
          - xiaomi_mi-router-ax3000t
          - xiaomi_mi-router-ax3000t-stock
          - xiaomi_mi-router-wr30u-112m
          - xiaomi_mi-router-wr30u-stock
      enable_5g_25db:
        description: 'Enable 5G 25dB high power mode'
        type: boolean
        required: true
        default: true
      upload_bin_dir:
        description: 'Upload bin directory'
        type: boolean
        required: false
        default: false
      start_from_compile:
        description: 'Start directly from the build step (requires environment setup)'
        type: boolean
        required: false
        default: false
  schedule:
    - cron: '0 21 * * *' # UTC 21:00 = Asia/Shanghai 05:00

permissions:
  contents: write
  actions: write

env:
  REPO_URL: https://github.com/padavanonly/immortalwrt-mt798x-24.10
  REPO_BRANCH: 2410
  FEEDS_CONF: feeds.conf.default
  CONFIG_FILE: 2410.config
  DIY_P1_SH: scripts/diy-part1.sh
  DIY_P2_SH: scripts/diy-part2.sh
  UPLOAD_FIRMWARE: true
  UPLOAD_RELEASE: true
  TZ: Asia/Shanghai
  WEBDAV_URL: ${{ secrets.WEBDAV_URL }}
  WEBDAV_USERNAME: ${{ secrets.WEBDAV_USERNAME }}
  WEBDAV_PASSWORD: ${{ secrets.WEBDAV_PASSWORD }}

jobs:
  check-source:
    runs-on: ubuntu-22.04
    if: github.event_name == 'schedule'
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Clone source and check for updates
        working-directory: /tmp
        run: |
          git clone ${{ env.REPO_URL }} -b ${{ env.REPO_BRANCH }} openwrt
          cd openwrt
          CURRENT_HASH=$(git rev-parse HEAD)
          echo "Current commit hash: $CURRENT_HASH"
          echo "CURRENT_HASH=$CURRENT_HASH" >> $GITHUB_ENV

      - name: Check if source has updated
        id: check
        run: |
          # Check if previous hash file exists (stored as artifact)
          if [ -f "/tmp/last_build_hash.txt" ]; then
            LAST_HASH=$(cat /tmp/last_build_hash.txt)
            echo "Last build hash: $LAST_HASH"
            if [ "$LAST_HASH" != "${{ env.CURRENT_HASH }}" ]; then
              echo "Source has updated, triggering build."
              echo "should_build=true" >> $GITHUB_OUTPUT
            else
              echo "Source has not updated, skipping build."
              echo "should_build=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "No previous build hash found, triggering build."
            echo "should_build=true" >> $GITHUB_OUTPUT
          fi
          # Save current hash to temporary file
          echo "${{ env.CURRENT_HASH }}" > /tmp/last_build_hash.txt

      - name: Upload hash file as artifact
        uses: actions/upload-artifact@v4
        with:
          name: last-build-hash
          path: /tmp/last_build_hash.txt

  build:
    runs-on: ubuntu-22.04
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'schedule' && needs.check-source.outputs.should_build == 'true')
    name: Build for ${{ matrix.device_model }}
    strategy:
      matrix:
        device_model: ${{ github.event_name == 'schedule' && fromJSON('["cmcc_rax3000m-usboffload", "cmcc_rax3000m-emmc-usboffload"]') || fromJSON(format('["{0}"]', github.event.inputs.device_model)) }}
    steps:
      - name: Set device display name
        run: |
          case "${{ matrix.device_model }}" in
            "cmcc_rax3000m") DISPLAY_NAME="中国移动 RAX3000M" ;;
            "cmcc_rax3000m-emmc") DISPLAY_NAME="中国移动 RAX3000M eMMC版" ;;
            "cmcc_rax3000m-usboffload") DISPLAY_NAME="中国移动 RAX3000M USB卸载版" ;;
            "cmcc_rax3000m-emmc-usboffload") DISPLAY_NAME="中国移动 RAX3000M eMMC USB卸载版" ;;
            "abt_asr3000") DISPLAY_NAME="ABT ASR3000" ;;
            "cetron_ct3003") DISPLAY_NAME="赛创 CT3003" ;;
            "cmcc_a10") DISPLAY_NAME="中国移动 A10" ;;
            "h3c_nx30pro") DISPLAY_NAME="H3C NX30 Pro" ;;
            "imou_lc-hx3001") DISPLAY_NAME="IMOU LC-HX3001" ;;
            "jcg_q30") DISPLAY_NAME="JCG Q30" ;;
            "konka_komi-a31") DISPLAY_NAME="康佳 KOMI-A31" ;;
            "livinet_zr-3020") DISPLAY_NAME="Livinet ZR-3020" ;;
            "mt7981-360-t7-108M") DISPLAY_NAME="MT7981 360 T7 108M" ;;
            "mt7981-clt-r30b1") DISPLAY_NAME="MT7981 CLT R30B1" ;;
            "mt7981-clt-r30b1-112M") DISPLAY_NAME="MT7981 CLT R30B1 112M" ;;
            "xiaomi_mi-router-ax3000t") DISPLAY_NAME="小米路由器 AX3000T" ;;
            "xiaomi_mi-router-ax3000t-stock") DISPLAY_NAME="小米路由器 AX3000T 原厂版" ;;
            "xiaomi_mi-router-wr30u-112m") DISPLAY_NAME="小米路由器 WR30U 112M" ;;
            "xiaomi_mi-router-wr30u-stock") DISPLAY_NAME="小米路由器 WR30U 原厂版" ;;
            *) DISPLAY_NAME="${{ matrix.device_model }}" ;;
          esac
          echo "DISPLAY_NAME=$DISPLAY_NAME" >> $GITHUB_ENV

      - name: Debug information
        run: |
          echo "Trigger type: ${{ github.event_name }}"
          echo "Device model: ${{ matrix.device_model }}"
          echo "Device display name: ${{ env.DISPLAY_NAME }}"
          echo "Start from compile: ${{ github.event.inputs.start_from_compile }}"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Ensure full history is checked out to include all files

      - name: Verify script files
        run: |
          echo "Checking for script files in $GITHUB_WORKSPACE..."
          ls -la $GITHUB_WORKSPACE/scripts || echo "Scripts directory not found!"
          if [ -f "$GITHUB_WORKSPACE/$DIY_P1_SH" ]; then
            echo "Found $DIY_P1_SH"
          else
            echo "Error: $DIY_P1_SH not found! Creating a default script..."
            mkdir -p $GITHUB_WORKSPACE/scripts
            cat << 'EOF' > $GITHUB_WORKSPACE/$DIY_P1_SH
            #!/bin/bash
            echo "Running default diy-part1.sh script..."
            # Add custom commands here if needed
            EOF
            chmod +x $GITHUB_WORKSPACE/$DIY_P1_SH
          fi
          if [ -f "$GITHUB_WORKSPACE/$DIY_P2_SH" ]; then
            echo "Found $DIY_P2_SH"
          else
            echo "Error: $DIY_P2_SH not found! Creating a default script..."
            mkdir -p $GITHUB_WORKSPACE/scripts
            cat << 'EOF' > $GITHUB_WORKSPACE/$DIY_P2_SH
            #!/bin/bash
            echo "Running default diy-part2.sh script..."
            # Add custom commands here if needed
            EOF
            chmod +x $GITHUB_WORKSPACE/$DIY_P2_SH
          fi

      - name: Download previous hash file (for scheduled runs)
        if: github.event_name == 'schedule'
        uses: actions/download-artifact@v4
        with:
          name: last-build-hash
          path: /tmp

      - name: Initialize environment
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          sudo rm -rf /etc/apt/sources.list.d/* /usr/share/dotnet /usr/local/lib/android /opt/ghc /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force
          sudo -E apt-get -qq update
          sudo -E apt-get -qq install -y ack antlr3 asciidoc autoconf automake autopoint binutils bison build-essential \
            bzip2 cmake cpio curl device-tree-compiler fastjar flex gawk gettext gcc-multilib g++-multilib \
            git gperf haveged help2man intltool libc6-dev-i386 libelf-dev libfuse-dev libglib2.0-dev libgmp3-dev \
            libltdl-dev libmpc-dev libmpfr-dev libncurses5-dev libncursesw5-dev libpython3-dev libreadline-dev \
            libssl-dev libtool lrzsz mkisofs msmtp ninja-build p7zip p7zip-full patch pkgconf python2.7 python3 \
            python3-pyelftools python3-setuptools qemu-utils rsync scons squashfs-tools subversion swig texinfo \
            uglifyjs upx-ucl unzip vim wget xmlto xxd zlib1g-dev zip
          sudo -E apt-get -qq autoremove --purge
          sudo -E apt-get -qq clean
          sudo timedatectl set-timezone "$TZ"
          sudo mkdir -p /workdir
          sudo chown $USER:$GROUPS /workdir

      - name: Prepare source and dependencies
        working-directory: /workdir
        run: |
          # Clean working directory if not starting from compile
          if [ "${{ github.event.inputs.start_from_compile }}" != "true" ]; then
            if [ -d "/workdir/openwrt" ]; then
              rm -rf /workdir/openwrt
              echo "Cleaned /workdir/openwrt directory."
            fi
          fi

          # Clone source if directory does not exist
          if [ ! -d "/workdir/openwrt" ]; then
            echo "Directory /workdir/openwrt not found, cloning source..."
            df -hT $PWD
            git clone $REPO_URL -b $REPO_BRANCH openwrt
            ln -sf /workdir/openwrt $GITHUB_WORKSPACE/openwrt
          else
            echo "Directory /workdir/openwrt already exists, skipping clone."
          fi

          cd /workdir/openwrt

          # Load feeds if needed
          if [ ! -f "feeds.conf.default" ] && [ "${{ github.event.inputs.start_from_compile }}" != "true" ]; then
            echo "Loading feeds..."
            [ -e $FEEDS_CONF ] && mv $FEEDS_CONF feeds.conf.default
            if [ -f "$GITHUB_WORKSPACE/$DIY_P1_SH" ]; then
              chmod +x $GITHUB_WORKSPACE/$DIY_P1_SH
              $GITHUB_WORKSPACE/$DIY_P1_SH
            else
              echo "Warning: $DIY_P1_SH not found, skipping diy-part1.sh execution."
            fi
            ./scripts/feeds update -a
            ./scripts/feeds install -a
          else
            echo "Feeds already exist or starting from compile, skipping feed setup."
          fi

          # Load configuration if needed
          if [ ! -f ".config" ] && [ "${{ github.event.inputs.start_from_compile }}" != "true" ]; then
            echo "Loading configuration..."
            [ -e files ] && mv files openwrt/files
            [ -e $CONFIG_FILE ] && mv $CONFIG_FILE .config
            echo "CONFIG_TARGET_mediatek_mt7981_DEVICE_${{ matrix.device_model }}=y" >> .config
            if [ -f "$GITHUB_WORKSPACE/$DIY_P2_SH" ]; then
              chmod +x $GITHUB_WORKSPACE/$DIY_P2_SH
              $GITHUB_WORKSPACE/$DIY_P2_SH
            else
              echo "Warning: $DIY_P2_SH not found, skipping diy-part2.sh execution."
            fi
            make defconfig
          else
            echo "Configuration file .config already exists or starting from compile, skipping configuration."
          fi

          # Download packages if needed
          if [ ! -d "dl" ] && [ "${{ github.event.inputs.start_from_compile }}" != "true" ]; then
            echo "Directory dl not found, downloading packages..."
            make download -j8
            find dl -size -1024c -exec ls -l {} \;
            find dl -size -1024c -exec rm -f {} \;
          else
            echo "Directory dl already exists or starting from compile, skipping download."
          fi

      - name: Modify 5G 25dB
        if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.event.inputs.enable_5g_25db == 'true')
        working-directory: /workdir/openwrt
        run: |
          mkdir -p package/mtk/drivers/mt_wifi/files/mt7981-default-eeprom
          printf '\x2B\x2B\x2B\x2B\x2B\x2B\x2B\x2B\x2B\x2B\x2B\x2B\x2B\x2B\x2B\x2B\x2B\x2B\x2B\x2B' | dd of=package/mtk/drivers/mt_wifi/files/mt7981-default-eeprom/MT7981_iPAiLNA_EEPROM.bin bs=1 seek=$((0x445)) conv=notrunc

      - name: Build firmware
        id: compile
        timeout-minutes: 120
        run: |
          set -e
          cd /workdir/openwrt
          echo -e "$(nproc) threads for compilation"
          make -j$(nproc) || make -j1 || { make -j1 V=s && exit 1; }
          echo "status=success" >> $GITHUB_OUTPUT
          echo "DEVICE_NAME=_${{ matrix.device_model }}" >> $GITHUB_ENV
          echo "FILE_DATE=_$(date +"%Y%m%d%H%M")" >> $GITHUB_ENV

      - name: Check disk space
        if: always()
        run: |
          df -hT

      - name: Upload bin directory
        uses: actions/upload-artifact@v4
        if: steps.compile.outputs.status == 'success' && (github.event_name == 'workflow_dispatch' && github.event.inputs.upload_bin_dir == 'true')
        with:
          name: OpenWrt_bin${{ env.DEVICE_NAME }}${{ env.FILE_DATE }}
          path: /workdir/openwrt/bin

      - name: Organize firmware and simplify filenames
        id: organize
        if: env.UPLOAD_FIRMWARE == 'true' && steps.compile.outputs.status == 'success'
        run: |
          set -e
          cd /workdir/openwrt/bin/targets/*/*
          rm -rf packages
          for file in *sysupgrade.bin *factory.bin; do
            if [ -f "$file" ]; then
              TYPE=$(echo "$file" | grep -o "sysupgrade\|factory")
              NEW_NAME="${{ matrix.device_model }}_$(date +"%Y%m%d%H%M")_25dB-${{ (github.event_name == 'schedule' || github.event.inputs.enable_5g_25db == 'true') && 'on' || 'off' }}_${TYPE}.bin"
              mv "$file" "$NEW_NAME"
            fi
          done
          echo "FIRMWARE=$PWD" >> $GITHUB_ENV
          echo "status=success" >> $GITHUB_OUTPUT

      - name: Filter and compress firmware
        id: compress
        if: steps.compile.outputs.status == 'success'
        run: |
          set -e
          cd ${{ env.FIRMWARE }}
          mkdir -p temp
          find . -type f \( -name "*sysupgrade.bin" -o -name "*factory.bin" \) -exec cp {} temp/ \;
          cd temp
          ZIP_NAME="${{ matrix.device_model }}${{ env.FILE_DATE }}_25dB-${{ (github.event_name == 'schedule' || github.event.inputs.enable_5g_25db == 'true') && 'on' || 'off' }}.zip"
          zip -r "$ZIP_NAME" .
          echo "ZIP_PATH=$PWD/$ZIP_NAME" >> $GITHUB_ENV
          echo "status=success" >> $GITHUB_OUTPUT

      - name: Generate tag and release description
        id: tag
        if: env.UPLOAD_RELEASE == 'true' && steps.compile.outputs.status == 'success'
        run: |
          set -e
          echo "release_tag=v24.10-${{ matrix.device_model }}" >> $GITHUB_OUTPUT
          cat << EOF > release.txt
          # ImmortalWrt 24.10 - ${{ matrix.device_model }}

          **版本**: 24.10  
          **设备**: ${{ env.DISPLAY_NAME }}  
          **编译时间**: $(date +"%Y-%m-%d %H:%M %Z")  
          **高功率模式**: ${{ (github.event_name == 'schedule' || github.event.inputs.enable_5g_25db == 'true') && '已启用' || '未启用' }}  

          ### 下载
          - 固件文件已附在此发布下方  
          - 源码: [immortalwrt-mt798x-24.10](https://github.com/padavanonly/immortalwrt-mt798x-24.10)

          ### 使用方法
          1. 确认设备型号匹配  
          2. 备份原始固件  
          3. 通过 Web 或 SSH 刷入

          > **注意**: 使用不当可能损坏设备，请谨慎操作！
          EOF
          echo "status=success" >> $GITHUB_OUTPUT

      - name: Publish firmware to GitHub Release
        uses: softprops/action-gh-release@v2
        if: steps.tag.outputs.status == 'success'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.tag.outputs.release_tag }}
          body_path: release.txt
          files: |
            ${{ env.FIRMWARE }}/*sysupgrade.bin
            ${{ env.FIRMWARE }}/*factory.bin
          overwrite: true

      - name: Upload firmware to GitHub Artifacts
        uses: actions/upload-artifact@v4
        if: steps.organize.outputs.status == 'success'
        with:
          name: OpenWrt_firmware${{ env.DEVICE_NAME }}${{ env.FILE_DATE }}
          path: |
            ${{ env.FIRMWARE }}/*sysupgrade.bin
            ${{ env.FIRMWARE }}/*factory.bin

      - name: Upload to WebDAV
        if: steps.compress.outputs.status == 'success' && env.WEBDAV_URL && env.WEBDAV_USERNAME && env.WEBDAV_PASSWORD
        run: |
          set -e
          curl -u "${{ env.WEBDAV_USERNAME }}:${{ env.WEBDAV_PASSWORD }}" -T "${{ env.ZIP_PATH }}" "${{ env.WEBDAV_URL }}/${{ env.ZIP_NAME }}"

      - name: Delete old workflow runs
        if: steps.tag.outputs.status == 'success'
        uses: Mattraks/delete-workflow-runs@v2
        with:
          retain_days: 0
          keep_minimum_runs: 2
